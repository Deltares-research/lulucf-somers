{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "264ee9eb",
   "metadata": {},
   "source": [
    "# Calculate spatial emissions\n",
    "\n",
    "This tutorial is a full example how to calculate spatial emissions for BGT-soilmap combinations based on modelled emission data. We will use the data from the previous [coverage](./coverage.ipynb) and [flux](./flux.ipynb) examples in the same area.\n",
    "\n",
    "First, we will load the data and define the grid."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "938bc6d2",
   "metadata": {},
   "outputs": [],
   "source": [
    "import xarray as xr\n",
    "\n",
    "import lusos\n",
    "\n",
    "xresolution = yresolution = 25\n",
    "xmin, ymin, xmax, ymax = 111_000, 455_000, 116_000, 460_000\n",
    "\n",
    "grid = lusos.LassoGrid(xmin, ymin, xmax, ymax, xresolution, yresolution)\n",
    "\n",
    "bgt = lusos.data.sample_bgt()\n",
    "soilmap = lusos.data.sample_soilmap()\n",
    "emissions = lusos.data.sample_emissions()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cf822709",
   "metadata": {},
   "source": [
    "First, we do the necessary preprocessing of the emissions data again."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "61b7cbe1",
   "metadata": {},
   "outputs": [],
   "source": [
    "emissions.columns = emissions.columns.str.lower()\n",
    "emissions.rename(columns={\"emission_t\": \"median\"}, inplace=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c055516e",
   "metadata": {},
   "source": [
    "Now we have the data loaded and the grid defined, we can calculate the spatial coverages of BGT-soilmap combinations and GHG fluxes"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4e660de5",
   "metadata": {},
   "outputs": [],
   "source": [
    "coverage = lusos.bgt_soilmap_coverage(bgt, soilmap, grid)\n",
    "flux = lusos.calculate_somers_emissions(emissions, grid) # flux per m2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ee62a2bc",
   "metadata": {},
   "source": [
    "The idea is to assign an emission value based for every cell in the example area. However, when we plot the calculated flux, we see that not every cell has data. This is because in this example, we use modelled CO2 emission (i.e. an out flux of CO2) from [SOMERS](https://www.nobveenweiden.nl/wp-content/uploads/2024/11/rapportage-SOMERS-2.0-technische-beschrijving.pdf), which only has data for the BGT type \"percelen\". Therefore, we can only assign these modelled values to certain cells that have combination \"percelen-{some soilmap type}\"."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a896ab8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "flux.plot.imshow()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd14d905",
   "metadata": {},
   "source": [
    "We need to fill the missing values in another way. For this, lusos has emission factors available for BGT-soilmap combinations that we can use for the missing values. Our example area is situated in the \"low-Netherlands\". We can load emission factors for this."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "50396f0d",
   "metadata": {},
   "outputs": [],
   "source": [
    "ef_factors = lusos.data.ef_low_netherlands()\n",
    "print(ef_factors.shape)\n",
    "ef_factors.head()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a7c7b25",
   "metadata": {},
   "source": [
    "We can multiply these emission factors with the coverage percentages and the cell area to get the flux per BGT-soilmap combination in each cell based on the emission factors. The result has a flux value for every x,y-location."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02b799a4",
   "metadata": {},
   "outputs": [],
   "source": [
    "flux_ef_factors = coverage * ef_factors.loc[coverage[\"layer\"], \"co2_uit\"].values[None, None, :]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b363d689",
   "metadata": {},
   "source": [
    "We need to combine these fluxes with the previously calculated SOMERS fluxes. To do this, we must make sure that we do not double count the BGT-soilmap combinations that contain \"percelen\". However, we still need to include the cells that contain any of those combinations but do not have a modelling result from SOMERS. We can do this in the steps shown below:\n",
    "\n",
    "1. Sum the fluxes of BGT-soilmap combinations that contain \"percelen\".\n",
    "2. Combine with the summed fluxes with the SOMERS fluxes -> take the SOMERS fluxes when available, otherwise take the summed flux.\n",
    "3. Sum the fluxes of the remaining BGT-soilmap combinations and add these to the result of step 2."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9cf77a76",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Step 1\n",
    "flux_parcels = flux_ef_factors.sel(layer=coverage[\"layer\"].str.contains(\"percelen\")).sum(dim=\"layer\")\n",
    "\n",
    "# Step 2\n",
    "flux = xr.where(flux > 0, flux, flux_parcels)\n",
    "\n",
    "# Step 3\n",
    "flux_others = flux_ef_factors.sel(layer=~coverage[\"layer\"].str.contains(\"percelen\")).sum(dim=\"layer\")\n",
    "flux_total = flux + flux_others\n",
    "\n",
    "flux_total.plot.imshow()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "38ed0025",
   "metadata": {},
   "source": [
    "The resulting grid is now a weighted average greenhouse gas flux based on the contributions of BGT-soilmap combinations and SOMERS modelling results."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "default",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
